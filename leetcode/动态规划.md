# LeetCode（动态规划）

## 动态规划

动态规划和递归相似，动态规划特点记录每次执行结果。后一次依赖前一次执行结果（状态转移）

状态转移方程

`dp[i][j] = 当前条件 && dp[i+1][j-1]`

边界条件

`j-1和i+1是否满足最小边界的情况`

dp实际上是一个二维数组

如下题回文串（给你一个字符串 s，找到 s 中最长的回文子串）

`如果dp[i][j]依赖dp[i+1][j-1]，说明表格中依赖二维数组的左下角`

| 左边边界\右边边界 | 0    | 1    | 2    | 3    | 4    |
| ----------------- | ---- | ---- | ---- | ---- | ---- |
| 0                 |      |      |      |      |      |
| 1                 |      |      |      |      |      |
| 2                 |      |      |      |      |      |
| 3                 |      |      |      |      |      |
| 4                 |      |      |      |      |      |

`dp[i][j] = s[i] == s[j] && dp[i+1][j-1]``条件（j-1）-（i+1）<2 -> j-i<3`

细节：

1. 数据长度为j-i+1
2. 如果计算二维数组时，判断对角线右上就i<j;对角线左下的就是i>j
3. 若从列表开始就是j=0
4. substring结果是左闭右开，`s.substring(begin,begin+maxLen)`
5. 二维数组创建 `boolean[][] dp = new boolean[s.length()][s.length()];`

------

## 动态规划题型二

题型二：最终结果由之前的每一次结果中最有解选择，需要对每一个项都求出最优解

如题找零钱所示top322

```
给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数
假设给定｛1，5，7，9｝找14元钱。最方便的是14=7+7
状态转移方程： dp[i] = 1+dp[i-coins[j]]
前提是 coins[j] <= i 
如下面表格所示，依次类推记录之前每个的最优解
```

| 0    | 1    | 2        | 3        | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   | 13   | 14   |
| ---- | ---- | -------- | -------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0    | 1    | 2（1+1） | 2（2+1） |      |      |      |      |      |      |      |      |      |      |      |

